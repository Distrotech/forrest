<?xml version="1.0"?>
<!--
  Copyright 1999-2004 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">
	<map:components>
    <map:pipes default="caching">
	   <map:pipe name="caching"
	    src="org.apache.cocoon.components.pipeline.impl.CachingProcessingPipeline"/>
	   <map:pipe name="noncaching"
	    src="org.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline"/>
	  </map:pipes>
		<map:selectors>
      <map:selector logger="sitemap.selector.exists" name="exists" src="org.apache.forrest.sourceexists.SourceExistsSelector" />
    </map:selectors>
    <map:generators default="file">
      <map:generator name="html"      
                     src="org.apache.cocoon.generation.HTMLGenerator">
        <jtidy-config>jtidy.properties</jtidy-config>
      </map:generator>
      <map:generator name="directory" src="org.apache.cocoon.generation.DirectoryGenerator" />
      </map:generators>
    <map:transformers default="xslt">
      <map:transformer name="cinclude"
        src="org.apache.cocoon.transformation.CIncludeTransformer"/>
      <map:transformer name="xinclude"
        src="org.apache.cocoon.transformation.XIncludeTransformer"/>
      <map:transformer name="i18n" src="org.apache.cocoon.transformation.I18nTransformer">
	      <catalogues default="contracts">
	        <catalogue id="other" name="OtherMessages" location="messages"/>
	        <catalogue id="contracts" name="ContractsMessages" location="messages"/>
	      </catalogues>
	      <cache-at-startup>true</cache-at-startup>
	    </map:transformer>
    </map:transformers>
    <map:serializers>
	   <map:serializer logger="sitemap.serializer.xhtml" mime-type="text/html" name="xhtml" pool-grow="2" pool-max="64" pool-min="2" src="org.apache.cocoon.serialization.XMLSerializer">
	      <!--+
	          | You can choose from Strict, Transitional, or Frameset XHTML.
	          | For Strict XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	          | For Transitional XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Transitional//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</doctype-system>
	          | For Frameset XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Frameset//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</doctype-system>
	          |
	          | Default XHTML doctype in Cocoon is XHTML Strict. If you want to use more than one
	          | XHTML DTD simultaneously, you can define several XHTML serializers.
	          +-->
	      <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	      <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	      <encoding>UTF-8</encoding>
        <indent>yes</indent>
	    </map:serializer>
      <map:serializer name="txt" 
			   src="org.apache.cocoon.serialization.TextSerializer"
			   mime-type="text/plain" 
			   logger="sitemap.serializer.text" 
			 />
    </map:serializers>
  </map:components>
<map:pipelines>

<!--
  This plugin provides a skin implementation based on views
  -->
  
<!--
  common skining
  This is the template producing factory.
  -->
 <map:pipeline type="noncaching">
  <!--
    FIXME:
    The next pipes have to be refactored and then to go into the view-interface (internal plugin)
    e.g. resources/templates/{1}.ft -> should become 
    first {project:view-skin}/templates/{1}.ft 
    then {project:skin}/templates/{1}.ft
    -->
  <!--FIXME:START-->
  <!--
    Resolving factory
    Project implementation of templates have priority before default ones.
    If no implementation can be found we use the noFt (~ - no forrest:template) implementation.
    {1} name of the contract-->
  <map:match pattern="resolve.contract.xhtml.*">
    <map:select type="exists">
      <map:when test="{project:resources}/templates/{1}.ft">
        <map:generate src="{project:resources}/templates/{1}.ft"/>
      </map:when>
      <map:when test="{forrest:plugins}/templates/{1}.ft">
        <map:generate src="{forrest:plugins}/templates/{1}.ft"/>
      </map:when>
      <map:when test="resources/templates/{1}.ft">
        <map:generate src="resources/templates/{1}.ft"/>
      </map:when>
      <map:otherwise>
        <map:generate src="resources/templates/noFt.ft"/>
      </map:otherwise>
    </map:select>
    <map:serialize type="xml"/>
  </map:match>
  
  <!--This activates forrest:call-templates includes into the view.-->
    <map:match pattern="prepare.view-templates.**">
      <map:select type="exists">
      <map:when test="{project:resources}/templates/{1}.vt.xml">
        <map:generate src="{project:resources}/templates/{1}.vt.xml"/>
      </map:when>
      <map:when test="resources/templates/{1}.vt.xml">
        <map:generate src="resources/templates/{1}.vt.xml"/>
      </map:when>
      <!-- otherwiser no view Tiles not found -->
      </map:select>
      <map:transform src="{defaults:view-internal}/resources/stylesheets/prepare.include.templates.xsl"/>
      <map:transform type="xinclude"/>
      <map:serialize type="xml"/>
    </map:match>
  
   <!-- <!-#-INTERFACE
    Get the xsl:templates of the requested contract.
  {1} format to deliver
  {2} contract name-#->
   <map:match pattern="get.contract.*.*">
     <map:generate src="cocoon:/resolve.contract.{2}"/>
     <map:transform src="resources/stylesheets/contract.xsl">
      <!-#-Which output format?-#->
      <map:parameter name="format" value="{1}"/>
     </map:transform>
     <map:serialize type="xml"/>
   </map:match>-->
  
  <!--IMPLEMENTATION
    Get the xsl:templates of the requested contract.
  {html} format to deliver
  {2} contract name-->
   <map:match pattern="get.contract.*.xhtml">
     <map:generate src="cocoon:/resolve.contract.xhtml.{1}"/>
     <map:transform src="resources/stylesheets/contract.xsl">
      <!--Which output format?-->
      <map:parameter name="format" value="xhtml"/>
     </map:transform>
     <map:transform type="i18n">
       <map:parameter name="locale" value="{request:locale}"/>
     </map:transform>
     <map:serialize type="xml"/>
   </map:match>
  <!--
  Get the forrest:properties of the requested contract. 
  This will determine which templates (css, head, body) we have to call later on
  {1} format to deliver
  {2} contract name
  -->
   <map:match pattern="get.contract-property.*.xhtml">
     <map:generate src="cocoon:/resolve.contract.xhtml.{1}"/>
     <map:transform src="resources/stylesheets/contract.property.xsl">
      <!--Which output format?-->
      <map:parameter name="format" value="xhtml"/>
     </map:transform>
     <map:serialize type="xml"/>
   </map:match>
   </map:pipeline>
  <!--
  Get the css of the requested contract {1}. 
  -->
<!--   <map:match pattern="get.contract-css.*">
     <map:generate src="cocoon:/resolve.contract.xhtml.{1}"/>
     <map:transform src="resources/stylesheets/contract.css.xsl"/>
     <map:serialize type="txt"/>
   </map:match>-->
<!--FIXME:END-->
<!--
    FIXME:
    The next pipes have to be refactored and then to go into an input plugin
    e.g. resources/templates -> should become 
    first {project:view-skin}/templates 
    then {project:skin}/templates
    -->
  <!--FIXME:START-->
<!-- ls.fbits 
  list the default fbits-->
  <map:pipeline>
    <map:match pattern="ls.contracts">
		  <map:generate type="directory" src="resources/templates">
        <map:parameter name="depth" value="1"/>
        <!-- sorted alphabetically -->
      	<map:parameter name="reverse" value="false"/>
      </map:generate>
      <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>
<!-- ls.fbits 
  list the project fbits-->
  <map:pipeline>
    <map:match pattern="ls.contracts.project">
		  <map:generate type="directory" src="{project:resources}/templates/">
        <map:parameter name="depth" value="1"/>
        <!-- sorted alphabetically -->
      	<map:parameter name="reverse" value="false"/>
      </map:generate>
      <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>

  <map:pipeline>
<!--
  Debug pipes - JTidy output
  -->
		<map:match pattern="*.tidy">
      <map:generate type="html" src="cocoon:/{1}.html"/>
     	<map:serialize type="xhtml"/>
    </map:match>
    <map:match pattern="**/*.tidy">
      <map:generate type="html" src="cocoon:/{1}/{2}.html"/>
     	<map:serialize type="xhtml"/>
    </map:match>
  <!--
  Last processing step. 
  Here we are overriding the default skin generation.
  -->   
    <map:match pattern="*.html">
      <map:generate src="cocoon://{1}.page"/>
      <map:transform src="cocoon://getStylesheet.xhtml.{1}">
        <map:parameter name="path" value="{0}"/>
      </map:transform>
      <map:transform src="resources/stylesheets/strip_namespaces.xsl"/>
     	<map:serialize type="xhtml"/>
    </map:match>
    <map:match pattern="**/*.html">
      <map:generate src="cocoon://{1}/{2}.page"/>
      <map:transform src="cocoon://getStylesheet.xhtml.{1}/{2}">
        <map:parameter name="path" value="{0}"/>
      </map:transform>
      <map:transform src="resources/stylesheets/strip_namespaces.xsl"/>
     	<map:serialize type="xhtml"/>
    </map:match>
  
  <map:match pattern="**.js">
        <map:mount uri-prefix="" src="resources.xmap" check-reload="yes" />
      </map:match>
      <map:match pattern="**.css">
        <map:mount uri-prefix="" src="resources.xmap" check-reload="yes" />
      </map:match>
      <map:match pattern="**images**">
        <map:mount uri-prefix="" src="resources.xmap" check-reload="yes" />
      </map:match>
      <map:match pattern="**.png">
        <map:mount uri-prefix="" src="resources.xmap" check-reload="yes" />
      </map:match>
     <map:match pattern="**.ico">
        <map:mount uri-prefix="" src="resources.xmap" check-reload="yes" />
      </map:match>
  </map:pipeline>
  
</map:pipelines>

</map:sitemap>
