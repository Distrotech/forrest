<?xml version="1.0"?>
<!--
  Copyright 1999-2004 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!-- forrest:structurer
***********************
The structuring of the assembled page where all content is in place
and structured with forrest:hooks to provide hooks for theming.

It is the job of a forrest:structurer to define this structure. The
structurer uses for this a couple of helper classes forrest:contracts,
forrest:hooks and forrest:properties. But there is more to a
forrest:structurer than just structure. 

The structurer is not limited to a document but can request and
structure the content from multiple input sources. Far more actually
because it provides as well logical conditions for presentation formatting logic
-->

<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">
  <map:components>
    <map:pipes default="caching">
      <map:pipe name="caching" 
        src="org.apache.cocoon.components.pipeline.impl.CachingProcessingPipeline"/>
      <map:pipe name="noncaching" 
        src="org.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline"/>
    </map:pipes>
    <map:selectors>
      <map:selector logger="sitemap.selector.exists" name="exists" 
        src="org.apache.forrest.sourceexists.SourceExistsSelector" />
    </map:selectors>
    <map:generators default="file">
      <map:generator name="traverse" 
        src="org.apache.cocoon.generation.TraversableGenerator" 
        logger="sitemap.generator.traverse" label="content" pool-max="16" />
      <map:generator name="directory" 
        src="org.apache.cocoon.generation.DirectoryGenerator" />
      <!--map:generator name="jx" logger="sitemap.generator.jx" 
        src="org.apache.cocoon.template.JXTemplateGenerator" 
        label="content,data" pool-max="16"-->
      <map:generator name="jx" logger="sitemap.generator.jx" 
        src="org.apache.cocoon.generation.JXTemplateGenerator" 
        label="content,data" pool-max="16">
      </map:generator>
    </map:generators>
    <map:transformers default="xslt">
      <map:transformer logger="sitemap.transformer.jx" name="jx" pool-max="16" 
        src="org.apache.cocoon.transformation.JXTemplateTransformer"/>
      <map:transformer logger="sitemap.transformer.jpath" name="jpath" 
        src="org.apache.cocoon.transformation.JPathTransformer"/>
      <map:transformer name="cinclude" 
        src="org.apache.cocoon.transformation.CIncludeTransformer"/>
      <map:transformer name="xinclude" 
        src="org.apache.cocoon.transformation.XIncludeTransformer"/>
    </map:transformers>
    <map:serializers default="xml">
      <map:serializer logger="sitemap.serializer.xhtml" mime-type="text/html" 
        name="xhtml" pool-grow="2" pool-max="64" pool-min="2" 
        src="org.apache.cocoon.serialization.XMLSerializer">
        <!--+
            | You can choose from Strict, Transitional, or Frameset XHTML.
            | For Strict XHTML set doctype to:
            |   <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
            |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
            | For Transitional XHTML set doctype to:
            |   <doctype-public>-//W3C//DTD XHTML 1.0 Transitional//EN</doctype-public>
            |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</doctype-system>
            | For Frameset XHTML set doctype to:
            |   <doctype-public>-//W3C//DTD XHTML 1.0 Frameset//EN</doctype-public>
            |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</doctype-system>
            |
            | Default XHTML doctype in Cocoon is XHTML Strict. If you want to use more than one
            | XHTML DTD simultaneously, you can define several XHTML serializers.
            +-->
        <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
        <doctype-system> 
          http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
        <encoding>UTF-8</encoding>
      </map:serializer>
      <map:serializer name="text" 
        src="org.apache.cocoon.serialization.TextSerializer" 
        mime-type="text/plain" logger="sitemap.serializer.text" />
    </map:serializers>
    <map:actions>
      <map:action name="fallbackResolverAction" 
        src="org.apache.forrest.plugin.internal.view.acting.FallbackResolverAction"/>
    </map:actions>
  </map:components>
  <map:resources>
    <map:resource name="skinit">
      <map:select type="exists">
        <map:when 
          test="{project:skins-dir}{project:theme}/xslt/html/{type}.xsl">
          <map:transform 
            src="{project:skins-dir}{project:theme}/xslt/html/{type}.xsl">
            <map:parameter name="notoc" value="{notoc}"/>
            <!-- FIXME: do we need this anymore? -->
            <!-- For backwards-compat with 0.2 - 0.4 skins -->
            <map:parameter name="isfaq" value="{notoc}"/>
            <map:parameter name="nopdf" value="{nopdf}"/>
            <map:parameter name="path" value="{path}"/>
            <map:parameter name="config-file" value="{project:skinconf}"/>
          </map:transform>
        </map:when>
        <map:otherwise>
          <map:transform src="resources/stylesheets/html/{type}.xsl">
            <map:parameter name="notoc" value="{notoc}"/>
            <!-- For backwards-compat with 0.2 - 0.4 skins -->
            <map:parameter name="isfaq" value="{notoc}"/>
            <map:parameter name="nopdf" value="{nopdf}"/>
            <map:parameter name="path" value="{path}"/>
            <map:parameter name="config-file" value="{project:skinconf}"/>
          </map:transform>
        </map:otherwise>
      </map:select>
      <map:serialize/>
    </map:resource>
  </map:resources>
  <map:pipelines>
    <map:pipeline>
      <!-- businessHelper -->
      <map:mount uri-prefix="" src="dataModel.xmap" check-reload="yes" 
        pass-through="true"/>
    </map:pipeline>
   
<!--
  structurer
  prepares and transforms the requested contracts (themes) and populate them with the content (businessHelper).
  -->
    <map:pipeline>
<!--FIXME: 
  type="jx" and move to lm
  
    View config resolver
    File specific views have priority before default ones.
    If no views can be found in the project we use the default one of the view plugin.
    {1} - requested url
    -->
      <map:match pattern="prepare.jxWorkaround.**">
        <map:act type="fallbackResolverAction">
          <map:parameter value="{1}" name="request"/>
          <map:parameter value="{project:theme}" name="projectFallback"/>
          <map:parameter value="{project:theme-ext}" name="projectExtension"/>
          <map:parameter value="{project:content.xdocs}" name="projectDir"/>
          <map:parameter value="{defaults:view-themes}" name="defaultDir"/>
          <map:parameter value="{defaults:theme}" name="defaultFallback"/>
          <map:parameter value="{defaults:theme-ext}" name="defaultExtension"/>
          <map:generate src="{uri}"/>
          <map:transform 
            src="resources/stylesheets/prepare.include.templates.xsl"/>
          <map:transform type="xinclude"/>
          <map:serialize/>
        </map:act>
      </map:match>
      
      <map:match pattern="prepare.view.**">
        <map:generate type="jx" src="cocoon:/prepare.jxWorkaround.{1}">
          <map:parameter name="lenient-xpath" value="true"/>
          <map:parameter name="getRequest" value="{1}"/>
        </map:generate>
        <map:serialize/>
      </map:match>
    
      <!--
        Add businessHelper to the presentation model that the content can be used later on.
        {1} - requested url -->
      <map:match pattern="prepare.view-nugget.**">
        <map:generate src="cocoon:/prepare.view.{1}">
          <map:parameter name="lenient-xpath" value="true"/>
          <map:parameter name="getRequest" value="{1}"/>
        </map:generate>
        <map:transform src="resources/stylesheets/prepare.view.xsl">
          <map:parameter name="view" value="{1}"/>
        </map:transform>
        <map:transform type="xinclude"/>
        <map:serialize/>
      </map:match>
      <!--
  Aggregate the contract-templates requested by the view with xinclude.
  The result is a stylesheet with all needed xsl:templates.
  {1} - format
  {2} - requested url
  -->
      <map:match pattern="prepare.include.*.**">
        <map:generate src="cocoon:/prepare.view.{2}"/>
        <map:transform src="resources/stylesheets/prepare.include.xsl">
          <map:parameter name="config-file" value="{project:skinconf}"/>
          <!--Which output format?-->
          <map:parameter name="format" value="{1}"/>
        </map:transform>
        <map:transform type="xinclude"/>
        <map:serialize/>
      </map:match>
      <!--
      Aggregate the forrest:properties requested by the *.fv.
      The result is an aggregation of properties which defines the templates to be call.
      {1} - format
      {2} - requested url
      -->
      <map:match pattern="prepare.properties.*.**">
        <map:generate src="cocoon:/prepare.view.{2}"/>
        <map:transform src="resources/stylesheets/prepare.properties.xsl">
          <!--Which output format?-->
          <map:parameter name="format" value="{1}"/>
        </map:transform>
        <map:transform type="xinclude"/>
        <map:serialize/>
      </map:match>
      <!--FIXME
      This has to be an interface and not an implementation. Use lm to do it.
      
      An interface will only generate cocoon protocol matches and serialize them!
      An implementation will deliver the actual match (including transformation)-->
      <!--
      Aggregate all contracts-templates requested by the view.
      Create a xsl that can be used for the last step of the transformation of the view.
      {1} - format
      {2} - requested url
      -->
      <map:match pattern="getStylesheet.*.**">
        <map:aggregate element="filter">
          <map:part src="cocoon://prepare.view-nugget.{2}" />
          <map:part src="cocoon://prepare.properties.{1}.{2}" />
        </map:aggregate>
        <map:transform src="resources/stylesheets/prepare.{1}.xsl" >
          <map:parameter name="request" value="{2}"/>
          <map:parameter name="forrestContext" value="{forrest:context}"/>
        </map:transform>
        <map:transform type="xinclude"/>
        <map:serialize/>
      </map:match>
    </map:pipeline>
  </map:pipelines>
</map:sitemap>
