<?xml version="1.0"?>
<!--
  Copyright 1999-2004 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">

	<map:components>
	<map:pipes default="caching">
	   <map:pipe name="caching"
	    src="org.apache.cocoon.components.pipeline.impl.CachingProcessingPipeline"/>
	   <map:pipe name="noncaching"
	    src="org.apache.cocoon.components.pipeline.impl.NonCachingProcessingPipeline"/>
	  </map:pipes>
		<map:selectors>
      <map:selector logger="sitemap.selector.exists" name="exists" src="org.apache.forrest.sourceexists.SourceExistsSelector" />
    </map:selectors>
    <map:generators default="file">
      <map:generator 
        name="traverse" 
        src="org.apache.cocoon.generation.TraversableGenerator" 
        logger="sitemap.generator.traverse" 
        label="content" 
        pool-max="16"
      />
      <map:generator name="directory" src="org.apache.cocoon.generation.DirectoryGenerator" />
      <map:generator label="content" logger="sitemap.generator.jx" name="jx" pool-grow="2" pool-max="16" pool-min="2" src="org.apache.cocoon.generation.JXTemplateGenerator"/>
    </map:generators>
    <map:transformers default="xslt">
      <map:transformer name="cinclude"
        src="org.apache.cocoon.transformation.CIncludeTransformer"/>
      <map:transformer name="xinclude"
        src="org.apache.cocoon.transformation.XIncludeTransformer"/>
    </map:transformers>
    <map:serializers>
	   <map:serializer logger="sitemap.serializer.xhtml" mime-type="text/html" name="xhtml" pool-grow="2" pool-max="64" pool-min="2" src="org.apache.cocoon.serialization.XMLSerializer">
	      <!--+
	          | You can choose from Strict, Transitional, or Frameset XHTML.
	          | For Strict XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	          | For Transitional XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Transitional//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</doctype-system>
	          | For Frameset XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Frameset//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</doctype-system>
	          |
	          | Default XHTML doctype in Cocoon is XHTML Strict. If you want to use more than one
	          | XHTML DTD simultaneously, you can define several XHTML serializers.
	          +-->
	      <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	      <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	      <encoding>UTF-8</encoding>
	    </map:serializer>
      <map:serializer name="text" 
			   src="org.apache.cocoon.serialization.TextSerializer"
			   mime-type="text/plain" 
			   logger="sitemap.serializer.text" 
			 />
    </map:serializers>
  </map:components>

<map:pipelines>

<!--
  This plugin has x components:
  2. businessHelper - delivers content that is used in the contracts
  3. views - transforms the requested contracts (viewHelper) 
     and populate them with the content (businessHelper)
  -->



<!--
  3. views
  prepares and transforms the requested contracts (viewHelper) and populate them with the content (businessHelper).
  -->
  <map:pipeline type="noncaching">
    <!--Refactor for dir-->
    <map:match pattern="viewLocationmap.xml">
      <map:generate type="traverse" src="{project:content.xdocs}">
        <map:parameter name="depth" value="100"/>
        <map:parameter name="exclude" value="[\w]*.svn"/>
        <!--<map:parameter name="include" value="[\w]*.fv"/>-->
      </map:generate>
      <map:transform src="resources/stylesheets/viewLocationmap.xsl"/>
    	<map:serialize type="xml"/>
    </map:match>
    

  <!--
    View config resolver
    File specific views have priority before default ones.
    If no views can be found in the project we use the default one of the view plugin.
    {1} - requested url
    -->
    <map:match pattern="prepare.view.**">
      <map:generate src="cocoon:/viewLocationmap.xml"/>
      <map:transform src="resources/stylesheets/viewLocationmap2path.xsl"/>
      <map:select type="exists">
      	<map:when test="resources/views/{project:defaultView}">
		      <map:transform src="resources/stylesheets/includes-viewLocationmap.xsl">
		        <map:parameter value="{project:defaultView}" name="defaultView"/>
		        <map:parameter value="{1}" name="path"/>
		        <map:parameter value="{project:content.xdocs}" name="root"/>
		        <map:parameter value="resources/views/{project:defaultView}" name="viewFallback"/>
		      </map:transform>
        </map:when>
        <map:otherwise>
		      <map:transform src="resources/stylesheets/includes-viewLocationmap.xsl">
		        <map:parameter value="{project:defaultView}" name="defaultView"/>
		        <map:parameter value="{1}" name="path"/>
		        <map:parameter value="{project:content.xdocs}" name="root"/>
		        <map:parameter value="resources/views/default.fv" name="viewFallback"/>
		      </map:transform>
        </map:otherwise>
      </map:select>
      <map:transform type="xinclude"/>
      <map:transform src="resources/stylesheets/prepare.include.templates.xsl"/>
      <map:transform type="xinclude"/>
    	<map:serialize type="xml"/>
    </map:match>
    
    <!--Add businessHelper to the presentation model that the content can be used later on.
        {1} - requested url-->
    
    <map:match pattern="prepare.view-nugget.**">
      <map:generate src="cocoon:/prepare.view.{1}"/>
      <map:transform src="resources/stylesheets/prepare.view.xsl">
        <map:parameter name="view" value="{1}"/>
      </map:transform>
      <map:transform type="xinclude"/>
     	<map:serialize type="xml"/>
    </map:match>
    
<!--
  Aggregate the contract-templates requested by the view with xinclude.
  The result is a stylesheet with all needed xsl:templates.
  {1} - format
  {2} - requested url
  -->
    <map:match pattern="prepare.include.*.**">
      <map:generate src="cocoon:/prepare.view.{2}"/>
      <map:transform src="resources/stylesheets/prepare.include.xsl">
	      <map:parameter name="config-file" value="{project:skinconf}"/>
        <!--Which output format?-->
        <map:parameter name="format" value="{1}"/>
      </map:transform>
      <map:transform type="xinclude"/> 
     	<map:serialize type="xml"/>
    </map:match>
    
    <!--
      Aggregate the forrest:properties requested by the *.fv.
      The result is an aggregation of properties which defines the templates to be call.
      {1} - format
  		{2} - requested url
      -->
    <map:match pattern="prepare.properties.*.**">
      <map:generate src="cocoon:/prepare.view.{2}"/>
      <map:transform src="resources/stylesheets/prepare.properties.xsl">
        <!--Which output format?-->
        <map:parameter name="format" value="{1}"/>
      </map:transform>
      <map:transform type="xinclude"/>
     	<map:serialize type="xml"/>
    </map:match>
    <!--FIXME
      This has to be an interface and not an implementation
      
      An interface will only generate cocoon protocol matches and serialize them!
      An implementation will deliver the actual match (including transformation)-->
    <!--
      Aggregate all contracts-templates requested by the view.
      Create a xsl that can be used for the last step of the transformation of the view.
      {1} - format
      {2} - requested url
  		--> 
    <map:match pattern="getStylesheet.*.**">
      <map:aggregate element="forrest:filter">
        <map:part src="cocoon://prepare.view.{2}" />
        <map:part src="cocoon://prepare.properties.{1}.{2}" /> 
      </map:aggregate>
      <map:transform src="resources/stylesheets/prepare.{1}.xsl" >
        <map:parameter name="request" value="{2}"/>
	      <map:parameter name="forrestContext" value="{forrest:context}"/>
      </map:transform>
      <map:transform type="xinclude"/> 
     	<map:serialize type="xml"/>
    </map:match>
  </map:pipeline>
  
  <!--
  2. businessHelper
  This is the model producing factory.
  -->
<!--NOTE: 
  The current factory uses the models the skin (e.g. document2xhtml.xsl from pelt [default skin]).
  It is only exchanging the last model of the models the skin is producing (site2xhtml.xsl) till now.
  This will have to be changed in the future.
  -->  
  <map:pipeline>
    <map:match pattern="*.page">
				<map:aggregate element="site">
          <map:part src="cocoon://skinconf.xml"/>
          <map:part src="cocoon://build-info"/>
          <map:part src="cocoon://tab-{1}.html"/>
          <map:part src="cocoon://menu-{1}.html"/>
          <map:part src="cocoon://body-{1}.html"/>
          <map:part src="cocoon:/prepare.view-nugget.{1}"/>
        </map:aggregate>
        <map:serialize type="xml"/>
    </map:match>
    <map:match pattern="**/*.page">
        <map:aggregate element="site">
          <map:part src="cocoon://skinconf.xml"/>
          <map:part src="cocoon://build-info"/>
          <map:part src="cocoon://{1}/tab-{2}.html"/>
          <map:part src="cocoon://{1}/menu-{2}.html"/>
          <map:part src="cocoon://{1}/body-{2}.html"/>
          <map:part src="cocoon:/prepare.view-nugget.{1}/{2}"/>
        </map:aggregate>
        <map:serialize type="xml"/>
      </map:match>
      
  </map:pipeline>  

  
<!-- 
	2. businessHelper
	-->
  
 </map:pipelines>
</map:sitemap>
