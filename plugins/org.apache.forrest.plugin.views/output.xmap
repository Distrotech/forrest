<?xml version="1.0"?>
<!--
  Copyright 1999-2004 The Apache Software Foundation or its licensors,
  as applicable.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">

	<map:components>
		<map:selectors>
      <map:selector logger="sitemap.selector.exists" name="exists" src="org.apache.forrest.sourceexists.SourceExistsSelector" />
    </map:selectors>
    <map:generators default="file">
      <map:generator name="directory" src="org.apache.cocoon.generation.DirectoryGenerator" />
      <map:generator label="content" logger="sitemap.generator.jx" name="jx" pool-grow="2" pool-max="16" pool-min="2" src="org.apache.cocoon.generation.JXTemplateGenerator"/>
    </map:generators>
    <map:transformers default="xslt">
      <map:transformer name="cinclude"
        src="org.apache.cocoon.transformation.CIncludeTransformer"/>
      <map:transformer name="xinclude"
        src="org.apache.cocoon.transformation.XIncludeTransformer"/>
    </map:transformers>
    <map:serializers>
	   <map:serializer logger="sitemap.serializer.xhtml" mime-type="text/html" name="xhtml" pool-grow="2" pool-max="64" pool-min="2" src="org.apache.cocoon.serialization.XMLSerializer">
	      <!--+
	          | You can choose from Strict, Transitional, or Frameset XHTML.
	          | For Strict XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	          | For Transitional XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Transitional//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</doctype-system>
	          | For Frameset XHTML set doctype to:
	          |   <doctype-public>-//W3C//DTD XHTML 1.0 Frameset//EN</doctype-public>
	          |   <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd</doctype-system>
	          |
	          | Default XHTML doctype in Cocoon is XHTML Strict. If you want to use more than one
	          | XHTML DTD simultaneously, you can define several XHTML serializers.
	          +-->
	      <doctype-public>-//W3C//DTD XHTML 1.0 Strict//EN</doctype-public>
	      <doctype-system>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</doctype-system>
	      <encoding>UTF-8</encoding>
	    </map:serializer>
      <map:serializer name="txt" 
			   src="org.apache.cocoon.serialization.TextSerializer"
			   mime-type="text/plain" 
			   logger="sitemap.serializer.text" 
			 />
    </map:serializers>
  </map:components>

<map:pipelines>

<!--
  This plugin has three components:
  1. fbits - delivers contracts in form of xsl:templates
  2. nuggets - delivers content that is used in the contracts
  3. views - transforms the requested contracts (fbits) 
     and populate them with the content (nuggets)
  -->


<!--
  1. fbits
  This is the template producing factory.
  -->
 <map:pipeline>
  <!--
    Resolving factory
    Project implementation of templates have priority before default ones.
    If no implementation can be found we use the noFt (~ - no forrest:template) implementation.
    -->
  <map:match pattern="resolve.contract.*">
    <map:select type="exists">
      <map:when test="{project:resources}/templates/{1}.ft">
        <map:generate src="{project:resources}/templates/{1}.ft"/>
      </map:when>
      <map:when test="resources/templates/{1}.ft">
        <map:generate src="resources/templates/{1}.ft"/>
      </map:when>
      <map:otherwise>
        <map:generate src="resources/templates/noFt.ft"/>
      </map:otherwise>
    </map:select>
    <map:serialize type="xml"/>
  </map:match>
  <!--
    Get the xsl:templates of the requested contract.
  -->
   <map:match pattern="get.contract.*.*">
     <map:generate src="cocoon:/resolve.contract.{1}"/>
     <map:transform src="resources/stylesheets/contract.xsl">
      <!--Which output format?-->
      <map:parameter name="format" value="{2}"/>
     </map:transform>
     <map:serialize type="xml"/>
   </map:match>
<!--
  Get the forrest:properties of the requested contract. 
  This will determine which templates (css, head, body) we have to call later on
  -->
   <map:match pattern="get.contract-property.*">
     <map:generate src="cocoon:/resolve.contract.{1}"/>
     <map:transform src="resources/stylesheets/contract.property.xsl"/>
     <map:serialize type="xml"/>
   </map:match>
<!-- ls.fbits 
  list the default fbits-->
  <map:pipeline>
    <map:match pattern="ls.contracts">
		  <map:generate type="directory" src="resources/templates">
        <map:parameter name="depth" value="1"/>
        <!-- sorted alphabetically -->
      	<map:parameter name="reverse" value="false"/>
      </map:generate>
      <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>
<!-- ls.fbits 
  list the project fbits-->
  <map:pipeline>
    <map:match pattern="ls.contracts.project">
		  <map:generate type="directory" src="{project:resources}/templates/">
        <map:parameter name="depth" value="1"/>
        <!-- sorted alphabetically -->
      	<map:parameter name="reverse" value="false"/>
      </map:generate>
      <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>
<!--ls.fbits.l
transform this dir-list and add more information 
-->
  <map:pipeline>
    <map:match pattern="ls.contracts.l">
		  <map:generate src="cocoon:/ls.contracts"/>
      <map:transform src="resources/stylesheets/ls.contracts.xsl">
        <map:parameter name="contentDir" value="{forrest:plugins}/org.apache.forrest.plugin.views"/>
      </map:transform>
      <map:transform src="resources/stylesheets/ls.contracts.html.xsl"/>
      <map:serialize type="xhtml"/>
    </map:match>
  </map:pipeline>
<!--ls.fbits.l
transform this dir-list of the project and add more information 
-->
  <map:pipeline>
    <map:match pattern="ls.contracts.project.l">
		  <map:generate src="cocoon:/ls.contracts.project"/>
      <map:transform src="resources/stylesheets/ls.contracts.xsl">
        <map:parameter name="contentDir" value="{forrest:plugins}/org.apache.forrest.plugin.views"/>
      </map:transform>
      <map:transform src="resources/stylesheets/ls.contracts.html.xsl"/>
      <map:serialize type="xhtml"/>
    </map:match>
  </map:pipeline>
   <!--
    Get some util-templates from the common skin.
    -->
   <map:match pattern="commonSite2xhtml">
        <map:generate src="{forrest:context}/skins/common/xslt/html/site2xhtml.xsl"/>
        <map:serialize type="xml"/>
    </map:match>
    <map:match pattern="dotdots">
        <map:generate src="{forrest:context}/skins/common/xslt/html/dotdots.xsl"/>
        <map:serialize type="xml"/>
    </map:match>
    <map:match pattern="pathutils">
        <map:generate src="{forrest:context}/skins/common/xslt/html/pathutils.xsl"/>
        <map:serialize type="xml"/>
    </map:match>
    <map:match pattern="renderlogo">
        <map:generate src="{forrest:context}/skins/common/xslt/html/renderlogo.xsl"/>
        <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>
<!-- END
  1. fbits
  -->
<!--
  2. nuggets
  This is the content producing factory.
  -->
<!--NOTE: 
  The current factory uses the skin producing templates (e.g. document2xhtml.xsl).
  It is only exchanging the last step of a skin producing pipe (site2xhtml.xsl) till now.
  This will have to be changed in the future.
  -->  
  <map:pipeline>
    <map:match pattern="*.page">
				<map:aggregate element="site">
          <map:part src="cocoon://skinconf.xml"/>
          <map:part src="cocoon://build-info"/>
          <map:part src="cocoon://tab-{1}.html"/>
          <map:part src="cocoon://menu-{1}.html"/>
          <map:part src="cocoon://body-{1}.html"/>
          <map:part src="cocoon:/prepare.view.{1}"/>
        </map:aggregate>
        <map:serialize type="xml"/>
    </map:match>
  </map:pipeline>  
<!-- END
	2. nuggets
	-->
<!--
  3. views
  prepares and transforms the requested contracts (fbits) and populate them with the content (nuggets).
  -->
  <map:pipeline>
  <!--
    View config resolver
    File specific views have priority before default ones.
    If no views can be found in the project we use the default one of the view plugin.
    -->
    <map:match pattern="prepare.view.*">
      <map:select type="exists">
        <!--
          Here we will have to test, whether the requested page needs a specific view.
          This will be assumed as soon there is a .fv
          e.g. index.xml + index.fv
          -->
        <map:when test="{project:content.xdocs}{1}.fv">
          <map:generate src="{project:content.xdocs}{1}.fv"/>
        </map:when>
				<!--
          If there is no file specific view then use the default.fv of the project stored in "project.conf-dir".
          -->
        <map:when test="{project:conf}/default.fv">
          <map:generate src="{project:conf}/default.fv"/>
        </map:when>
        <!--
          If the above not matches then get the default view of this plugin.
          -->
        <map:otherwise>
          <map:generate src="src/documentation/default.fv"/>
        </map:otherwise>
      </map:select>
     	<map:serialize type="xml"/>
    </map:match>
    
<!--
  Aggregate the contract-templates requested by the view with xinclude.
  The result is a stylesheet with all needed xsl:templates.
  -->
    <map:match pattern="prepare.include.*">
      <map:generate src="cocoon:/prepare.view.{1}"/>
      <map:transform src="resources/stylesheets/prepare.include.xsl">
	      <map:parameter name="config-file" value="{project:skinconf}"/>
      </map:transform>
      <map:transform type="xinclude"/> 
     	<map:serialize type="xml"/>
    </map:match>
    
    <!--
      Aggregate the forrest:properties requested by the *.fv.
      The result is an aggregation of properties which defines the templates to be call.
      -->
    <map:match pattern="prepare.properties.*">
      <map:generate src="cocoon:/prepare.view.{1}"/>
      <map:transform src="resources/stylesheets/prepare.properties.xsl"/>
      <map:transform type="xinclude"/> 
     	<map:serialize type="xml"/>
    </map:match>
    <!--
      Aggregate all contracts-templates requested by the view.
      Create a xsl that can be used for the last step of the transformation of the view.
  		--> 
    <map:match pattern="prepare.xhtml.*">
      <map:aggregate element="forrest:filter">
        <map:part src="cocoon:/prepare.view.{1}" />
        <map:part src="cocoon:/prepare.properties.{1}" /> 
      </map:aggregate>
      <map:transform src="resources/stylesheets/prepare.xhtml.xsl" >
        <map:parameter name="request" value="{1}"/>
      </map:transform>
      <map:transform type="xinclude"/> 
     	<map:serialize type="xml"/>
    </map:match>
<!--
  Last processing step. 
  Here we are overriding the default skin generation.
  -->   
    <map:match pattern="*.html">
      <map:generate src="cocoon:/{1}.page"/>
      <map:transform src="cocoon:/prepare.xhtml.{1}"/>
     	<map:serialize type="xhtml"/>
    </map:match>
  </map:pipeline>
 </map:pipelines>
</map:sitemap>
