#!/bin/sh

###################################################
# Regenerate a site's HTML with the latest Forrest.
###################################################

SCRIPT=${1}
[ -z "$SCRIPT" ] && echo >&2 "Usage: $0 <forrestbot script>
Where <forrestbot script> is the name of a file in ../samples
Eg: $0 xml-forrest-template-cvs.xml" && exit 1

. `dirname $0`/local-vars
# default 20 minute timeout. 
export CVS_RSH=ssh
export PATH=$JAVA_HOME/bin:$PATH
TSTAMP=`date +%Y-%m-%d-%k-%M`
# Leaving EMAIL blank causes no email to be sent
EMAIL=
LOGS=$WEBAPP/logs
DEST_DIR=$WEBAPP/sites
PATH=$PATH:$HOME/apps/bin
# Assume we're in the xml-forrest/src/resources/forrestbot/scripts
[ -z "$FORREST" ] && FORREST=$BASE/../../../../
# Set this to true if you want to delete any local mods to the $FORREST and
# update from CVS.  Not recommended unless scripts/ is moved outside the
# xml-forrest CVS hierarchy
[ -z "$REGEN_FORREST" ] && REGEN_FORREST=false
# Set to true to delete the work/ directory, which contains forrestbot-checked
# out CVS source.  Setting to false is faster, but less safe
[ -z "$REGEN_WORK" ] && REGEN_WORK=true
FORRESTBOT_SCRIPTS=$FORREST/src/resources/forrestbot/samples

# Directory in which to build a clean version of Forrest
SHBAT=$BASE/shbat
# Work directory for CVS checkouts, forrestbot files etc.
WORK=$BASE/work


function setup()
{
	if [ ! -d $FORREST ]; then
		echo "$FORREST not present"
		exit
	fi
}

# Delete and rebuild the shbat distribution, optionally updating xml-forrest 
function rebuild_forrest()
{
  pushd .
  [ -d "$SHBAT" -a -e "$SHBAT/forrest.build.xml" ] && rm -r $SHBAT
  cd $FORREST
  # see www.red-bean.com/cvsutils
  if [ "$REGEN_FORREST" = "true" -a `which cvsco` ]; then
    > /tmp/forrest-is-being-regenned
    cvsco
    cvs up -dP
  fi
  > /tmp/forrest-being-rebuilt
  ./build.sh -Ddist-shbat.dir=$SHBAT
  popd
}

# Populate the work/ directory with customized forrestbot scripts
function prepare_workdir()
{
	pushd .
	[ "$REGEN_WORK" = "true" -a -d "$WORK" ] && rm -r $WORK
	if [ ! -d $WORK ]; then
		mkdir $WORK && cd $WORK
		cp -r $FORRESTBOT_SCRIPTS/* $WORK
	fi
	cd $WORK
	[ -d build/bot ] && rm build/bot/work*.log
	perl -i -pe "s:<!ENTITY email.*>:<!ENTITY email \"$EMAIL\">:g" $SCRIPT
	perl -i -pe "s:<!ENTITY dest.*>:<!ENTITY dest \"$DEST_DIR\">:g" $SCRIPT
	popd
}

# Run the forrestbot on $SCRIPT. Set a watchdog thread to kill the forrestbot
# if it seems to hang
function forrestbot()
{
	cd $WORK
	$SHBAT/bin/forrestbot -Dbot.config=$SCRIPT &
	cmdpid=$!
	# Start "watchdog" process to terminate the command
	# after $timeout seconds:
	( sleep $TIMEOUT; echo "Forrestbot timed out after $TIMEOUT	seconds" ;
	kill $cmdpid &&	(sleep 2; kill -1 $cmdpid) &&
				(sleep 2; kill -9 $cmdpid)
	) &
	watchdogpid=$!
	wait $cmdpid			# wait for command
	kill $watchdogpid >/dev/null 2>&1
}

# Copy forrestbot log files to webapp
function copy_logs()
{
	mkdir -p $LOGS/old
	for i in $WORK/build/bot/work*.log; do
		cp "$i" $LOGS
		cp "$i" $LOGS/old/`basename $i`-$TSTAMP
	done
	echo "Copied logs"
}

echo Running script $SCRIPT

setup
rebuild_forrest
prepare_workdir
forrestbot
copy_logs
